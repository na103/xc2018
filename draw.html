<html>
  <!--

  View coordinate data.
  -->
<head>
  <!--
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.min.js"></script>
-->
<script src="jquery.min.js"></script>
<script src="data.js"></script>
<script src="formula.js"></script>

<script>
$(document).ready(function() {
  window.onerror = function errorHandler(msg, url, line) {
    alert('Exception ' + msg + ' ' + url + ' ' + line);
    error('Exception ' + msg + ' ' + url + ' ' + line);
    return false;
  }

  // https://makitweb.com/drag-and-drop-file-upload-with-jquery-and-ajax/

  $("html").on("dragover", function(e) {
    e.preventDefault();
    e.stopPropagation();
  });

  $("html").on("drop", function (e) {
    e.preventDefault();
    e.stopPropagation();
    var files = e.originalEvent.dataTransfer.files;

    if (files.length != 1) {
      alert('Unexpected upload length ' + files.length);
      return;
    }
    var ucname = files[0].name.toUpperCase();
    if (ucname.endsWith('.LCA')) {
      files[0].text().then(lcaUpload);
    } else if (ucname.endsWith('.RBT')) {
      files[0].text().then(rbtUpload);
    } else {
      alert('Need to upload a .RBT or .LCA file.');
    }
  });

  function lcaUpload(contents) {
    $("#info").html('LCA: ' + contents);
  }

  $('#mode').on('change', function() {
    alert( this.value );
  });

  var rbtstream = null;
  var bitstream = null;
  /**
   * Handles the upload of a .RBT file, storing it into the variable bitstream, which has 160 lines of 71 '0'/'1' characters,
   * the contents of the .RBT file.
   */
  function rbtUpload(contents) {
    var lines = contents.split(/[\r\n]+/);
    var contents = [];
    var mode = 'header';
    for (var i = 0; i < lines.length; i++) {
      var line = lines[i]
      if (mode == 'header') {
        if (line.startsWith('0') && line.endsWith('111')) {
          mode = 'data';
        }
      }
      if (mode == 'data') {
        if (line.startsWith('1111')) {
          mode = 'done';
        } else if (line.startsWith('0') && line.endsWith('111')) {
          mode = 'data';
          var data = line.slice(1, -3);
          if (data.length != 71) {
            alert('Bad line length ' + data.length + ' in .RBT file');
            return;
          }
          contents.push(data);
        } else {
          alert('Bad data line in .RBT file');
          return;
        }
      }
    }
    if (contents.length != 160) {
      alert('Wrong number of data lines' + contents.length + ' in .RBT file');
      return;
    }
    rbtstream = contents;
    diestream = makeDiestream(rbtstream);
    displayStream(diestream);
  }

  /**
   * The RBT file is organized:
   * HH ... AH
   * .       .
   * HA ... AA
   * stored as rbtstream[line][char] of '0' and '1'.
   *
   * The die is organized:
   * AA ... AH
   * .       .
   * HA ... HH
   * This function flips the rbtstream to match the die, stored as diestream[x][y].
   * diestream also holds ints (not chars) and is inverted with respect to the bitstream, so 1 is active.
   * I'm using the term "diestream" to describe the bitstream with the die's layout and "rbtstream" to describe the bitstream
   * with the .RBT file's layout.
   */
  function makeDiestream(rbtstream) {
    var diestream = new Array(160);
    for (var x = 0; x < 160; x++) {
      diestream[x] = new Array(71);
      for (var y = 0; y < 71; y++) {
        diestream[x][y] = rbtstream[159 - x][70 - y] == '1' ? 0 : 1;
        
      }
    }
    return diestream;
  }

  /**
   * Displays the bitstream data.
   */
  function displayStream(diestream) {
    canvasMode = 'bitstream';
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

    // Draw labels
    ctx.canvas.height = 570;
    $("#container").css('height', '570px');
    ctx.font = "45pt arial";
    ctx.fillStyle = "#ddf";
    var SIZE = 8; // Each digit is a SIZE x SIZE block.
    var xpos = 3; // 3 bits to first cell.
    ctx.strokeStyle = "#ccc";
    ctx.beginPath();
    ctx.rect(0, 0, 160 * SIZE, 71 * SIZE);
    ctx.stroke();
    ctx.strokeStyle = "#fbb";
    ctx.beginPath();
    for (var x = 0; x < 8; x++) {
      if (x == 3 || x == 6) {
        xpos += 2; // Skip buffer
      }
      var ypos = 1; // 1 bit to first cell
      for (var y = 0; y < 8; y++) {
        if (y == 3 || y == 6) {
          ypos += 1; // Skip buffer
        }
        fillText("ABCDEFGH"[y] + "ABCDEFGH"[x], 30 + xpos * SIZE, 52 + ypos * SIZE);
        ctx.rect(xpos * SIZE, ypos * SIZE, 18 * SIZE, 8 * SIZE);
        ypos += 8; // 8 bits per tile
      }
      xpos += 18; // 18 bits per tile
    }
    ctx.stroke();

    // Draw data
    $("#img").css('opacity', 0);
    ctx.font = "9px arial";
    ctx.fillStyle = "black";
    for (var x = 0; x < 160; x++) {
      for (var y = 0; y < 71; y++) {
        fillText(diestream[x][y] == 0 ? ' ' : '1', 1 + x * SIZE, 7 + y * SIZE);
      }
    }
  }

  // Bit position starts for the tiles A through I. Note there is I/O before A and buffers between C-D and F-G.
  var xTileStarts = [3, 21, 39, 59, 77, 95, 115, 133, 151];

  /**
   * Take a bit index and return the tile A-I, along with starting bitstream index.
   */
  function findTileX(x) {
    for (var i = 8; i >= 0; i--) {
      if (x >= xTileStarts[i]) {
        if (x < xTileStarts[i] + 18) {
          return ["ABCDEFGHI"[i], xTileStarts[i], i];
        } else {
          return ["buf", xTileStarts[i] + 18, -1];
        }
      }
    }
    return ["io", 0, -2];
  }

  var yTileStarts = [1, 9, 17, 26, 34, 42, 51, 59, 67];

  /**
   * Take a bit index and return the tile A-I, along with starting bitstream index.
   */
  function findTileY(y) {
    for (var i = 8; i >= 0; i--) {
      if (y >= yTileStarts[i]) {
        if (y < yTileStarts[i] + 8) {
          return ["ABCDEFGHI"[i], yTileStarts[i], i];
        } else {
          return ["buf", yTileStarts[i] + 8, -1];
        }
      }
    }
    return ["io", 0, -2];
  }
  


  function bitstreamClick(x, y) {
    var xn = x / 8; // Convert to bit indices
    var yn = y / 8;
    var xinfo = findTileX(xn);
    var yinfo = findTileY(yn);
    if (xinfo[2] >= 0 && yinfo[2] >= 0) {
      $("#info3").html(tiles[xinfo[2]][yinfo[2]].decode());
    } else {
      $("#info3").html(x + ' ' + y + ' ' + xinfo + ' ' + yinfo);
    }
  }

// From row name to [internal Y coordinate, screen X coordinate]
var rowInfo = {
 "row.I.local.5": [0, 999],
 "row.I.long.2": [4, 646],
 "row.I.local.4": [6, 642],
 "row.I.local.3": [7, 638],
 "row.I.local.2": [9, 634],
 "row.I.local.1": [10, 630],
 "row.I.long.1": [12, 624],
 "row.I.local.0": [17, 604],

 "row.A.local.5": [160, 52],
 "row.A.long.3": [161, 48],
 "row.A.local.4": [163, 42],
 "row.A.local.3": [164, 38],
 "row.A.local.2": [166, 34],
 "row.A.local.1": [167, 30],
 "row.A.long.2": [169, 26],
 "row.A.local.0": [173, 999],
}

// From column name to [internal X coordinate, screen X coordinate]
var colInfo = {
 "col.A.local.0": [0, 999],
 "col.A.long.2": [3, 22],
 "col.A.local.1": [5, 26],
 "col.A.local.2": [6, 30],
 "col.A.local.3": [8, 34],
 "col.A.local.4": [9, 38],
 "col.A.long.3": [11, 44],
 "col.A.long.4": [12, 48],
 "col.A.local.5": [14, 56],

 "col.I.local.0": [167, 618],
 "col.I.long.1": [169, 626],
 "col.I.long.2": [170, 630],
 "col.I.local.1": [172, 636],
 "col.I.local.2": [173, 640],
 "col.I.local.3": [175, 644],
 "col.I.local.4": [176, 648],
 "col.I.long.3": [178, 652],
 "col.I.local.5": [181, 999],
}

function initNames() {
  // Generate formulaic row and column names (B through H)
  for (var i = 1; i < 8; i++) {
    var cstart = 27 + 20 * (i-1);
    var name = "ABCDEFGHI"[i];

    colInfo['col.' + name + '.local.1'] = [cstart, 108 + 72 * (i-1)];
    colInfo['col.' + name + '.local.2'] = [cstart + 1, 112 + 72 * (i-1)];
    colInfo['col.' + name + '.local.3'] = [cstart + 3, 116 + 72 * (i-1)];
    colInfo['col.' + name + '.local.4'] = [cstart + 4, 120 + 72 * (i-1)];
    colInfo['col.' + name + '.local.5'] = [cstart + 6, 126 + 72 * (i-1)];
    colInfo['col.' + name + '.local.6'] = [cstart + 7, 130 + 72 * (i-1)];
    colInfo['col.' + name + '.long.1'] = [cstart + 8, 134 + 72 * (i-1)];
    colInfo['col.' + name + '.long.2'] = [cstart + 9, 138 + 72 * (i-1)];

    var rstart = 25 + 19 * (7 - i);
    rowInfo['row.' + name + '.long.1'] = [rstart, 132 + 72 * (i-1)];
    rowInfo['row.' + name + '.local.5'] = [rstart + 2, 126 + 72 * (i-1)];
    rowInfo['row.' + name + '.local.4'] = [rstart + 3, 122 + 72 * (i-1)];
    rowInfo['row.' + name + '.local.3'] = [rstart + 5, 118 + 72 * (i-1)];
    rowInfo['row.' + name + '.local.1'] = [rstart + 6, 114 + 72 * (i-1)];
    rowInfo['row.' + name + '.local.0'] = [rstart + 7, 112 + 72 * (i-1)];
  }
}

  class Clb {
    constructor(x, y, screenPt, lcaPt, bitPt) {
      this.x = x;
      this.y = y;
      this.name = "ABCDEFGH"[y] + "ABCDEFGH"[x];
      this.screenPt = screenPt;
      this.lcaPt = lcaPt;
      this.bitPt = bitPt;
    }

    draw() {
      ctx.strokeStyle = "red";
      ctx.beginPath();
      var x0 = this.screenPt[0];
      var y0 = this.screenPt[1];
      ctx.rect(x0, y0, 20, 32);
      ctx.moveTo(x0 + 16, y0 - 2);
      ctx.lineTo(x0 + 16, y0);

      ctx.moveTo(x0 - 2, y0 + 12);
      ctx.lineTo(x0, y0 + 12);
      ctx.moveTo(x0 - 2, y0 + 18);
      ctx.lineTo(x0, y0 + 18);
      ctx.moveTo(x0 - 2, y0 + 24);
      ctx.lineTo(x0, y0 + 24);

      ctx.moveTo(x0 + 10, y0 + 33);
      ctx.lineTo(x0 + 10, y0 + 35);

      ctx.moveTo(x0 + 21, y0 + 18);
      ctx.lineTo(x0 + 23, y0 + 18);
      ctx.moveTo(x0 + 21, y0 + 28);
      ctx.lineTo(x0 + 23, y0 + 28);

      ctx.stroke();
      ctx.font = "10px arial";
      ctx.fillStyle = "green";
      fillText(this.name, x0 + 1, y0 + 8);
    }

    /**
     * Decode this CLB from the bitstream.
     */
    decode() {
      var x = this.bitPt[0];
      var y = this.bitPt[1];
      var nf = 0;
      for (var bitnum = 0; bitnum < 8; bitnum++) {
        var bit = diestream[x + bitnum][y + 7];
        if (bit) {
          nf |= 1 << [1, 0, 2, 3, 5, 4, 6, 7][bitnum]; // Ordering of LUT is irregular
        }
      }
      var fin1 = diestream[x + 7][y + 6] ? 'A' : 'B';
      var fin2 = diestream[x + 6][y + 6] ? 'B' : 'C';
      var fin3 = 'Q';
      if (diestream[x + 1][y + 6]) {
        fin3 = 'C';
      } else if ( diestream[x + 0][y + 6]) {
        fin3 = 'D';
      }

      var ng = 0;
      for (var bitnum = 0; bitnum < 8; bitnum++) {
        bit = diestream[x + bitnum + 10][y + 7];
        if (bit) {
          ng |= 1 << [7, 6, 4, 5, 3, 2, 0, 1][bitnum]; // Ordering of LUT is irregular
        }
      }
      var gin1 = diestream[x + 11][y + 6] ? 'A' : 'B';
      var gin2 = diestream[x + 12][y + 6] ? 'B' : 'C';
      var gin3 = 'Q';
      if ( diestream[x + 16][y + 6]) {
        gin3 = 'C';
      } else if ( diestream[x + 17][y + 6]) {
        gin3 = 'D';
      }

      var str;
      if (diestream[x + 9][y + 7] != 1) {
        if (fin1 == gin1 && fin2 == gin2 && fin3 == gin3) {
          str = 'F = ' + formula4((nf << 8) | ng, fin1, fin2, fin3, 'B');
        } else {
          str = 'F = B*(' + formula3(nf, fin1, fin2, fin3) +
            ') + ~B*(' + formula3(ng, gin1, gin2, gin3) + ')';
        }
      } else {
        str = 'F = ' + formula3(nf, fin1, fin2, fin3);
        str += '<br/>G = ' + formula3(ng, gin1, gin2, gin3);
      }
      return str;
    }
  }

  class Pip {
    constructor(name, screenPt) {
      this.name = name;
      var parts = name.split(':');
      this.screenPt = [colInfo[parts[0]][1], rowInfo[parts[1]][1]];
      if (this.screenPt[0] == 999 || this.screenPt[1] == 999) {
        console.log('missing coord ' + name);
      }
    }

    draw() {
      ctx.strokeStyle = "red";
      ctx.beginPath();
      ctx.rect(this.screenPt[0] - 1, this.screenPt[1] - 1, 2, 2);
      ctx.stroke();
    }
  }

  class Tile {
    constructor(x, y, screenPt, lcaPt, bitPt) {
      this.x = x; // Index 0-8
      this.y = y;
      this.name = "ABCDEFGHI"[y] + "ABCDEFGHI"[x];
      this.screenPt = screenPt;
      this.lcaPt = lcaPt;
      this.bitPt = bitPt;
      this.pips = [];
      var screenX = screenPt[0] - 44;
      var screenY = screenPt[1] - 28
      if (x < 8 && y < 8) {
        this.clb = new Clb(x, y, [x * 72 + 78, y * 72 + 68], [x * 19, y * 20], bitPt);
      } else {
        this.clb = null;
      }

      var row = "ABCDEFGHI"[y];
      var col = "ABCDEFGHI"[x];
      // Substitute for ROW and COL in the pip name
      function rename(pip) {
        return pip.replace('ROW', row).replace('COL', col);
      }

      if (x == 0 && y == 0) {
        // Upper left
        this.switch1 = null;
        this.switch2 = null;
        screenX -= 13;
        screenY -= 15;

        var pips = [
          "col.A.long.2:row.A.long.2", "col.A.local.1:row.A.long.2", "col.A.long.3:row.A.long.2",
          "col.A.long.2:row.A.local.1", "col.A.local.1:row.A.local.1",
          "col.A.local.2:row.A.local.2",
          "col.A.local.3:row.A.local.3", "col.A.long.4:row.A.local.3",
          "col.A.local.4:row.A.local.4",
          "col.A.local.4:row.A.long.3", "col.A.long.3:row.A.long.3", "col.A.long.4:row.A.long.3"];
        pips.forEach(pip => this.pips.push(new Pip(rename(pip))));
      } else if (x < 8 && y == 0) {
        // Top edge
        var pips = [
          "col.COL.long.1:row.A.long.2",
          "col.COL.long.2:row.A.local.1",
          "col.COL.local.5:row.A.local.2", "col.COL.long.1:row.A.local.2",
          "col.COL.local.5:row.A.local.3", "col.COL.long.2:row.A.local.3",
          "col.COL.long.1:row.A.local.4",
          "col.COL.local.1:row.A.long.3", "col.COL.local.4:row.A.long.3", "col.COL.long.1:row.A.long.3", "col.COL.long.2:row.A.long.3"];
        screenY -= 12;
        this.switch1 = new Switch(this.name + '.8.1', 1, [screenX, screenY], [lcaPt[0] - 20, lcaPt[1] - 20], bitPt);
        this.switch2 = new Switch(this.name + '.8.2', 2, [screenX + 8, screenY + 8], [lcaPt[0] - 10, lcaPt[1] - 10], bitPt);
        pips.forEach(pip => this.pips.push(new Pip(rename(pip))));
      } else if (y == 0) {
        // upper right

        var pips = [
          "col.I.local.4:row.A.long.2", "col.I.long.3:row.A.long.2",
          "col.I.local.0:row.A.local.1", "col.I.local.4:row.A.local.1", "col.I.long.3:row.A.local.1",
          "col.I.local.0:row.A.local.2", "col.I.local.3:row.A.local.2",
          "col.I.local.0:row.A.local.3", "col.I.local.2:row.A.local.3",
          "col.I.local.1:row.A.local.4", "col.I.local.0:row.A.local.4",
          "col.I.local.0:row.A.long.3", "col.I.long.1:row.A.long.3", "col.I.long.2:row.A.long.3",
          "col.I.long.2:row.A.local.5", "col.I.local.1:row.A.local.5", "col.I.local.2:row.A.local.5", "col.I.local.3:row.A.local.5", "col.I.local.4:row.A.local.5"];
        pips.forEach(pip => this.pips.push(new Pip(rename(pip))));
      } else if (x == 0 && y < 8) {
        // left
        var pips = [
          "col.A.long.3:row.ROW.local.1",
          "col.A.long.4:row.ROW.local.3",
          "col.A.long.2:row.ROW.long.1", "col.A.local.1:row.ROW.long.1", "col.A.local.4:row.ROW.long.1", "col.A.long.3:row.ROW.long.1", "col.A.long.4:row.ROW.long.1"];
        screenX -= 10;
        this.switch1 = new Switch(this.name + '.8.1', 1, [screenX, screenY], [lcaPt[0] - 20, lcaPt[1] - 20], bitPt);
        this.switch2 = new Switch(this.name + '.8.2', 2, [screenX + 8, screenY + 8], [lcaPt[0] - 10, lcaPt[1] - 10], bitPt);
        pips.forEach(pip => this.pips.push(new Pip(rename(pip))));
      } else if (x < 8 && y < 8) {
        // center
        var pips = [
          "col.COL.local.5:row.ROW.local.0",
          "col.COL.long.2:row.ROW.local.1",
          "col.COL.local.5:row.ROW.local.3", "col.COL.local.6:row.ROW.local.3", "col.COL.long.1:row.ROW.local.3",
          "col.COL.local.5:row.ROW.local.4", "col.COL.local.6:row.ROW.local.4", "col.COL.long.2:row.ROW.local.4",
          "col.COL.long.1:row.ROW.local.5",
          "col.COL.local.1:row.ROW.long.1", "col.COL.local.4:row.ROW.long.1"];
        // Main part
        this.switch1 = new Switch(this.name + '.8.1', 1, [screenX, screenY], [lcaPt[0] - 20, lcaPt[1] - 20], bitPt);
        this.switch2 = new Switch(this.name + '.8.2', 2, [screenX + 8, screenY + 8], [lcaPt[0] - 10, lcaPt[1] - 10], bitPt);
        pips.forEach(pip => this.pips.push(new Pip(rename(pip))));
      } else if (y < 8) {
        // right
        var pips = [
          "col.I.long.2:row.ROW.local.1",
          "col.I.long.1:row.ROW.local.3",
          "col.I.long.2:row.ROW.local.4",
          "col.I.long.1:row.ROW.local.5",
          "col.I.long.1:row.ROW.long.1", "col.I.long.2:row.ROW.long.1", "col.I.local.1:row.ROW.long.1", "col.I.local.4:row.ROW.long.1", "col.I.long.3:row.ROW.long.1"];
        screenX += 24;
        this.switch1 = new Switch(this.name + '.8.1', 1, [screenX, screenY], [lcaPt[0] - 20, lcaPt[1] - 20], bitPt);
        this.switch2 = new Switch(this.name + '.8.2', 2, [screenX + 8, screenY + 8], [lcaPt[0] - 10, lcaPt[1] - 10], bitPt);
        pips.forEach(pip => this.pips.push(new Pip(rename(pip))));
      } else if (x == 0) {
        // bottom left

        var pips = [
          "col.A.local.1:row.I.local.0", "col.A.local.2:row.I.local.0", "col.A.local.3:row.I.local.0", "col.A.local.4:row.I.local.0", "col.A.long.3:row.I.local.0",
          "col.A.local.4:row.I.long.1", "col.A.long.3:row.I.long.1", "col.A.long.4:row.I.long.1", "col.A.local.5:row.I.long.1",
          "col.A.local.4:row.I.local.1", "col.A.local.5:row.I.local.1",
          "col.A.local.3:row.I.local.2", "col.A.long.4:row.I.local.2", "col.A.local.5:row.I.local.2",
          "col.A.local.2:row.I.local.3", "col.A.local.5:row.I.local.3",
          "col.A.long.2:row.I.local.4", "col.A.local.1:row.I.local.4", "col.A.local.5:row.I.local.4",
          "col.A.long.2:row.I.long.2", "col.A.local.1:row.I.long.2", "col.A.long.3:row.I.long.2"];
        pips.forEach(pip => this.pips.push(new Pip(rename(pip))));
      } else if (x < 8) {
        // bottom

        var pips = [
          "col.COL.local.1:row.I.long.1", "col.COL.local.4:row.I.long.1", "col.COL.long.1:row.I.long.1", "col.COL.long.2:row.I.long.1",
          "col.COL.long.1:row.I.local.1",
          "col.COL.local.5:row.I.local.2", "col.COL.long.2:row.I.local.2",
          "col.COL.local.5:row.I.local.3", "col.COL.long.1:row.I.local.3",
          "col.COL.long.2:row.I.local.4",
          "col.COL.long.1:row.I.long.2"];
        screenY += 12;
        this.switch1 = new Switch(this.name + '.8.1', 1, [screenX, screenY + 8], [lcaPt[0] - 20, lcaPt[1] - 10], bitPt);
        this.switch2 = new Switch(this.name + '.8.2', 2, [screenX + 8, screenY], [lcaPt[0] - 10, lcaPt[1] - 20], bitPt);
        pips.forEach(pip => this.pips.push(new Pip(rename(pip))));
      } else {
        // bottom right
        var pips = [
          "col.I.long.1:row.I.long.1", "col.I.long.2:row.I.long.1",
          "col.I.local.1:row.I.local.1",
          "col.I.local.2:row.I.local.2",
          "col.I.local.3:row.I.local.3",
          "col.I.local.4:row.I.local.4", "col.I.long.3:row.I.local.4",
          "col.I.local.4:row.I.long.2", "col.I.long.3:row.I.long.2"];
        pips.forEach(pip => this.pips.push(new Pip(rename(pip))));
      }
    }

    draw() {
      if (this.switch1 != null) {
        this.switch1.draw();
        this.switch2.draw();
      }
      if (this.clb) {
        this.clb.draw();
      }
      this.pips.forEach(pip => pip.draw());
    }

    /**
     * Decode this tile from the bitstream.
     * Returns string.
     */
    decode() {
      var result = [];
      if (this.clb) {
        result.push(this.clb.decode());
      }
      if (this.switch1 != null) {
        result.push(this.switch1.decode());
        result.push(this.switch2.decode());
      }
      return result.join('<br/>');
    }
  }

  class Switch {
    constructor(name, num, screenPt, lcaPt, bitPt) {
      this.name = name;
      this.num = num; // 1 or 2
      this.screenPt = screenPt;
      this.lcaPt = lcaPt;
      this.wires = null;
      this.bitPt = bitPt;
    }

    draw() {
      ctx.strokeStyle = "red";
      ctx.beginPath();
      var x0 = this.screenPt[0];
      var y0 = this.screenPt[1];
      ctx.rect(x0, y0, 8, 8);
      for (var i = 0; i < 8; i++) {
        ctx.moveTo(x0 + [2, 6, 9, 9, 6, 2, 0, 0][i], y0 + [0, 0, 2, 6, 9, 9, 6, 2][i]);
        ctx.lineTo(x0 + [2, 6, 10, 10, 6, 2, -2, -2][i], y0 + [-2, -2, 2, 6, 10, 10, 6, 2][i]);
      }
      ctx.stroke();
    }

    decodeInt() {
      if (this.bitPt[0] == 151) {
        console.log('switch todo')
        this.wires = [];
        return;
      }
      var wires = [];
      if (this.num == 1) {
        for (var x = 0; x < 9; x++) {
          if (diestream[this.bitPt[0] + x][this.bitPt[1] + 0] == 1) {
            wires.push([[6,0], [7,0], [2,6], [2,7], [4,0], [1,5], [1,2], [3,4], [3,5]][x]);
          }
          if (diestream[this.bitPt[0] + x][this.bitPt[1] + 1] == 1) {
            wires.push([[5,6], [3,7], [3,6], [1,7], [4,6], [1,4], [1,3], [2,4], [5,0]][x]);
          }
        }
        if (diestream[this.bitPt[0] + 0][this.bitPt[1] + 2] == 1) {
          wires.push([5,7]);
        }
        if (diestream[this.bitPt[0] + 8][this.bitPt[1] + 2] == 1) {
          wires.push([2,0]);
        }
      } else {
        for (var x = 0; x < 9; x++) {
          if (diestream[this.bitPt[0] + x + 9][this.bitPt[1] + 0] == 1) {
            wires.push([[4,6], [5,6], [7,0], [4,0], [1,5], [2,7], [3,7], [1,2], [1,3]][x]);
          }
          if (diestream[this.bitPt[0] + x + 9][this.bitPt[1] + 1] == 1) {
            wires.push([[1,4], [5,7], [6,8], [5,8], [3,5], [2,8], [3,6], [2,6], [3,4]][x]);
          }
        }
        if (diestream[this.bitPt[0] + 9][this.bitPt[1] + 2] == 1) {
          wires.push([1,7]);
        }
        if (diestream[this.bitPt[0] + 16][this.bitPt[1] + 2] == 1) {
          wires.push([2,4]);
        }
      }
      this.wires = wires;
    }

    decode() {
      this.decodeInt();
      var result = [];
      this.wires.forEach(x => result.push('(' + x[0] + ',' + x[1] + ')'));
      return result.join(',');
    }
  }

  var canvasMode = 'wiring';
  $("#canvas").mousemove(function(e) {
    var offset = $(this).offset();
    var x = e.pageX - offset.left;
    var y = e.pageY - offset.top;
    if (canvasMode == 'bitstream') {
      bitstreamClick(x, y);
    }
  });

  var ctx = $("#canvas")[0].getContext("2d");
  // Prevent antialiasing of lines
  ctx.translate(0.5, 0.5);
  var ctx2 = $("#canvas2")[0].getContext("2d");


  function fillText(text, x, y) {
    ctx.fillText(text, x + 0.5, y + 0.5);
  }

  function vtext(text, x, y) {
    for (var i = 0 ; i < text.length; i++) {
      fillText(text[i], x, y + 8 * i);
    }
  }

  function drawPin(name, x0, y0, style) {
    ctx.strokeStyle = "red";

    ctx.font = "10px arial";
    ctx.fillStyle = "green";
    ctx.beginPath();

    if (style == "a") { // top
      ctx.rect(x0, y0, 20, 12);
      ctx.moveTo(x0 + 8, y0);
      ctx.lineTo(x0 + 8, y0 - 2);

      ctx.moveTo(x0 + 8, y0+ 12);
      ctx.lineTo(x0 + 8, y0 + 15);
      ctx.moveTo(x0 + 12, y0+ 12);
      ctx.lineTo(x0 + 12, y0 + 15);
      ctx.moveTo(x0 + 16, y0+ 12);
      ctx.lineTo(x0 + 16, y0 + 15);
      ctx.stroke();
      fillText(name, x0 + 1, y0 + 8);
    } else if (style == "b") { // alternate top
      ctx.rect(x0, y0, 20, 12);
      ctx.moveTo(x0 + 4, y0);
      ctx.lineTo(x0 + 4, y0 - 2);

      ctx.moveTo(x0 + 4, y0+ 12);
      ctx.lineTo(x0 + 4, y0 + 15);
      ctx.moveTo(x0 + 8, y0+ 12);
      ctx.lineTo(x0 + 8, y0 + 15);
      ctx.moveTo(x0 + 12, y0+ 12);
      ctx.lineTo(x0 + 12, y0 + 15);
      ctx.stroke();
      fillText(name, x0 + 1, y0 + 8);
    } else if (style == "c") { // left
      ctx.rect(x0, y0, 12, 26);
      ctx.moveTo(x0 - 2, y0 + 12);
      ctx.lineTo(x0, y0 + 12);

      ctx.moveTo(x0+ 12, y0 + 12);
      ctx.lineTo(x0 + 15, y0 + 12);
      ctx.moveTo(x0+ 12, y0 + 16);
      ctx.lineTo(x0 + 15, y0 + 16);
      ctx.moveTo(x0+ 12, y0 + 20);
      ctx.lineTo(x0 + 15, y0 + 20);
      ctx.stroke();
      vtext(name, x0 + 1, y0 + 8);
    } else if (style == "d") { // right
      ctx.rect(x0, y0, 12, 26);
      ctx.moveTo(x0+ 12, y0 + 12);
      ctx.lineTo(x0 + 16,  y0 + 12);

      ctx.moveTo(x0 - 2, y0 + 12);
      ctx.lineTo(x0, y0 + 12);
      ctx.moveTo(x0 - 2, y0 + 16);
      ctx.lineTo(x0, y0 + 16);
      ctx.moveTo(x0 - 2, y0 + 20);
      ctx.lineTo(x0, y0 + 20);
      ctx.stroke();
      vtext(name, x0 + 1, y0 + 8);
    } else if (style == "e") { // bottom
      ctx.rect(x0, y0, 20, 12);
      ctx.moveTo(x0 + 8, y0 + 12);
      ctx.lineTo(x0 + 8, y0 + 14);

      ctx.moveTo(x0 + 8, y0 - 3);
      ctx.lineTo(x0 + 8, y0);
      ctx.moveTo(x0 + 12, y0 - 3);
      ctx.lineTo(x0 + 12, y0);
      ctx.moveTo(x0 + 16, y0 - 3);
      ctx.lineTo(x0 + 16, y0);
      ctx.stroke();
      fillText(name, x0 + 1, y0 + 8);
    } else if (style == "f") { // alternate bottom
      ctx.rect(x0, y0, 20, 12);
      ctx.moveTo(x0 + 4, y0 + 12);
      ctx.lineTo(x0 + 4, y0 + 14);

      ctx.moveTo(x0 + 4, y0 - 3);
      ctx.lineTo(x0 + 4, y0);
      ctx.moveTo(x0 + 8, y0 - 3);
      ctx.lineTo(x0 + 8, y0);
      ctx.moveTo(x0 + 12, y0 - 3);
      ctx.lineTo(x0 + 12, y0);
      ctx.stroke();
      fillText(name, x0 + 1, y0 + 8);
    }
  }

  function initPins() {
    drawPin("P9", 62, 6, "a");
    drawPin("P8", 90, 6, "b");
    drawPin("P7", 138, 6, "a");
    drawPin("P6", 162, 6, "b");
    drawPin("P5", 210, 6, "a");
    drawPin("P4", 234, 6, "b");
    drawPin("P3", 282, 6, "a");
    drawPin("P2", 306, 6, "b");
    drawPin("P68", 354, 6, "a");
    drawPin("P67", 378, 6, "b");
    drawPin("P66", 426, 6, "a");
    drawPin("P65", 450, 6, "b");
    drawPin("P64", 498, 6, "a");
    drawPin("P63", 522, 6, "b");
    drawPin("P62", 570, 6, "a");
    drawPin("P61", 594, 6, "b");

    drawPin("P27", 62, 656, "e");
    drawPin("P28", 90, 656, "f");
    drawPin("P29", 138, 656, "e");
    drawPin("P30", 162, 656, "f");
    drawPin("P31", 210, 656, "e");
    drawPin("P32", 234, 656, "f");
    drawPin("P33", 282, 656, "e");
    drawPin("P34", 306, 656, "f");
    drawPin("P36", 354, 656, "e");
    drawPin("P37", 378, 656, "f");
    drawPin("P38", 426, 656, "e");
    drawPin("P39", 450, 656, "f");
    drawPin("P40", 498, 656, "e");
    drawPin("P41", 522, 656, "f");
    drawPin("P42", 570, 656, "e");
    drawPin("P43", 594, 656, "f");

    for (var i = 0; i < 14; i++) {
      if (i == 7) continue;
      drawPin("P" + (11 + i), 6, 88 + 36 * i, "c");
    }

    for (var i = 0; i < 14; i++) {
      if (i == 7) continue;
      drawPin("P" + (59 - i), 656, 88 + 36 * i, "d");
    }
  }

  var tiles = new Array(9);
  function initTiles() {
    for (var x = 0; x < 9; x++) {
      tiles[x] = new Array(9);
      for (var y = 0; y < 9; y++) {
        var tile = new Tile(x, y, [x * 72 + 78, y * 72 + 68], [x * 19, y * 20], [xTileStarts[x], yTileStarts[y]]);
        tiles[x][y] = tile;
        tile.draw();
      }
    }
  }

  function init() {
    initNames();
    initPins();
    initTiles();
  }

  init();


});

</script>
<title>FPGA viewer: draw</title>
</head>
<body>
<div id="header">
<select id="mode"><option name="layout" selected>Layout</select><option name="bitstream">Bitstream</option></select>
</div>
<div id="info"> </div>
<div id="info2"> </div>
<div id="container" style="position: relative">
  <canvas style="position:absolute; z-index: 1" id="canvas" width=2000 height=2000></canvas>
  <img id="img" style="position:absolute" src="pips.png" width=680 height=680></img>
</div>
<div id="info3"> </div>
<canvas id="canvas2" width=300 height=300></canvas>
</body>
</html>
