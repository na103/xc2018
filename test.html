<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>Test Suite</title>
    <link rel="stylesheet" href="https://code.jquery.com/qunit/qunit-2.11.2.css">
  </head>
  <body>
    <div id="qunit"></div>
    <div id="qunit-fixture"></div>
    <script src="https://code.jquery.com/qunit/qunit-2.11.2.js"></script>
    <script src="draw.js"></script>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.min.js"></script>
    <div id="result"></div>
</body>

<script>
  function mkBitstream() {
    let bitstream = new Array(160);
    for (var x = 0; x < 160; x++) {
      bitstream[x] = new Array(71);
    }
    return bitstream;
  }

  function formula4(nf, f1, f2, f3, f4) {
    return nf + f1 + ' ' + f2 + ' ' + f3 + ' ' + f4;
  }

  function formula3(nf, f1, f2, f3) {
    return nf + f1 + ' ' + f2 + ' ' + f3;
  }

  QUnit.module('draw', { beforeEach: function() {
      initNames();
  }}, function() {

    QUnit.test('test initNames', function(assert) {
      assert.deepEqual(colInfo['col.A.local.1'], [5, 26], 'col.A.local.1');
    });

    QUnit.test('test pip', function(assert) {
      bitstream = mkBitstream();
      let pip = new Pip('col.A.long.2:row.A.local.5', [100, 50]);
      bitstream[100][50] = 1;
      pip.decode(bitstream);
      assert.deepEqual(pip.state, 1);

      bitstream[100][50] = 0;
      pip.decode(bitstream);
      assert.deepEqual(pip.state, 0);
    });

    QUnit.test('validate tile coords', function(assert) {
      initTiles();

      assert.deepEqual(tiles[0][0].screenPt, [78, 68]);
      assert.deepEqual(tiles[0][3].screenPt, [78, 284]);
      assert.deepEqual(tiles[0][8].screenPt, [78, 644]);
      assert.deepEqual(tiles[5][0].screenPt, [438, 68]);
      assert.deepEqual(tiles[5][7].screenPt, [438, 572]);
      assert.deepEqual(tiles[5][8].screenPt, [438, 644]);
      assert.deepEqual(tiles[8][0].screenPt, [654, 68]);
      assert.deepEqual(tiles[8][4].screenPt, [654, 356]);
      assert.deepEqual(tiles[8][8].screenPt, [654, 644]);

      assert.deepEqual(tiles[0][0].gPt, [0, 0]);
      assert.deepEqual(tiles[0][3].gPt, [0, 60]);
      assert.deepEqual(tiles[0][8].gPt, [0, 160]);
      assert.deepEqual(tiles[5][0].gPt, [95, 0]);
      assert.deepEqual(tiles[5][7].gPt, [95, 140]);
      assert.deepEqual(tiles[5][8].gPt, [95, 160]);
      assert.deepEqual(tiles[8][0].gPt, [152, 0]);
      assert.deepEqual(tiles[8][4].gPt, [152, 80]);
      assert.deepEqual(tiles[8][8].gPt, [152, 160]);

      assert.deepEqual(tiles[0][0].bitPt, [3, 1]);
      assert.deepEqual(tiles[0][3].bitPt, [3, 26]);
      assert.deepEqual(tiles[0][8].bitPt, [3, 67]);
      assert.deepEqual(tiles[5][0].bitPt, [95, 1]);
      assert.deepEqual(tiles[5][7].bitPt, [95, 59]);
      assert.deepEqual(tiles[5][8].bitPt, [95, 67]);
      assert.deepEqual(tiles[8][0].bitPt, [151, 1]);
      assert.deepEqual(tiles[8][4].bitPt, [151, 34]);
      assert.deepEqual(tiles[8][8].bitPt, [151, 67]);
    });

    // Reads all the SWn.RBT files and makes sure the appropriate Switch pins are connected.
    QUnit.test('switch files', function(assert) {
      let done = assert.async(120)
      for (var i = 0; i < 120; i++) {
        // These are all asynchronous because of the file fetching.
        // done() must be called filenames.length times for the test to complete.
        testSwitchFile('SWITCH' + i, assert, done);
      }
    });

    // Test the named file.
    function testSwitchFile(name, assert, done) {
      $.get( 'testfiles/' + name + '.RBT', function(rbt, status) {
        assert.equal(status, "success");
        $.get( 'testfiles/' + name + '.LCA', function(lca, status) {
          assert.equal(status, "success");
          // loaded rbt and lca
          let m = lca.match(/^;([^:]+):/)
          assert.ok(m);
          let sw = m[1]; // e.g "AC.8.1.5 AC.8.1.6"
          let pin1 = parseInt(sw[7]);
          let pin2 = parseInt(sw[16]);
          let x = sw.charCodeAt(1) - "A".charCodeAt(0);
          let y = sw.charCodeAt(0) - "A".charCodeAt(0);

          let tile = new Tile(x, y);
          let bitstream = rbtParse(rbt);
          tile.decode(bitstream);
          if (sw[5] == 1) {
            // Switch 1 has a wire
            assert.deepEqual(tile.switch1.wires, [[pin1, pin2]]);
            assert.deepEqual(tile.switch2.wires, []);
          } else if (sw[5] == 2) {
            // Switch 2 has a wire
            assert.deepEqual(tile.switch1.wires, []);
            assert.deepEqual(tile.switch2.wires, [[pin1, pin2]]);
          } else {
            assert.ok(false);
          }
          done();
        });
      });
    }

    QUnit.test('test clb', function(assert) {
      let done = assert.async();
      $.get( 'testfiles/CLBTEST.RBT', function(rbt, status) {
        assert.equal(status, "success");
        initTiles();
        let bitstream = rbtParse(rbt);
        // BB X:F, Y: G, Q: LATCH, SET: A, RES: D, CLK: K
        // assert.deepEqual(tiles[1][1].clb.decode(), 'X:F Y:G F:B:C:D G:A:B:Q Q:LATCH SET:A RES:D CLK:K')
        // assert.deepEqual(clbDecode, 'F = X:F Y:G F:B:C:D G:A:B:Q Q:LATCH SET:A RES:D CLK:K')
        let clbBB = tiles[1][1].clb
        clbBB.decode(bitstream);
        assert.equal(clbBB.configString, 'X:F Y:G F:B:C:D G:A:B:Q Q:LATCH SET:A RES:D CLK:K')
        assert.equal(clbBB.configBase, 'FG');
        assert.equal(clbBB.configNf, 0xd2);
        assert.equal(clbBB.configNg, 0x96);

        // BC: no settings, default
        let clbBC = tiles[2][1].clb
        clbBC.decode(bitstream);
        assert.equal(clbBC.configString, 'X:Q Y:Q F:B:C:Q G:B:C:Q Q:LATCH SET: RES: CLK:');
        assert.equal(clbBC.configBase, 'FG');
        assert.equal(clbBC.configNf, 0);
        assert.equal(clbBC.configNg, 0);

        // Base FG
        // Equate G = B+C
        let clbBD = tiles[3][1].clb
        clbBD.decode(bitstream);
        // TODO: strip out unused variables from F and G
        // assert.equal(clbBD.configString, 'X:Q Y:Q F: G:B:C Q:FF SET:F RES:G CLK:NOT');
        assert.equal(clbBD.configString, 'X:Q Y:Q F:B:C:Q G:B:C:Q Q:FF SET:F RES:G CLK:NOT');
        assert.equal(clbBD.configBase, 'FG');
        assert.equal(clbBD.configNf, 0xd2);

        // BE G F / / / C-NOT
        let clbBE = tiles[4][1].clb
        clbBE.decode(bitstream);
        assert.equal(clbBE.configString, 'X:G Y:F F: G: Q: SET: RES: CLK:C:NOT');
        assert.equal(clbBE.configBase, 'FG');
        assert.equal(clbBE.configNf, 0xd2);

        // BF G
        let clbBF = tiles[5][1].clb
        clbBF.decode(bitstream);
        assert.equal(clbBF.configString, 'X: Y: F: G: Q: SET: RES: CLK:G');
        assert.equal(clbBF.configBase, 'FG');
        assert.equal(clbBF.configNf, 0xd2);


        // AA: all clear, "base F", F = A+B+C+D
        // Editblk AA
        // Base F
        // Config X: Y: F:A:B:C:D Q: SET: RES: CLK: 
        // Equate F = A+B+C+D
        // 
        let clbAA = tiles[0][0].clb;
        clbAA.decode(bitstream);
        assert.equal(clbAA.configString, 'X: Y: F:B:C:D G:A:B:Q Q: SET: RES: CLK:');
        assert.equal(clbAA.configBase, 'F');
        assert.equal(clbAA.configNf, 0);
        assert.equal(clbAA.configNg, 0);

        // AG: G/G/FF/A/D/G, F=A
        // 
        // Editblk AG
        // Base FG
        // Config X:G Y:G F:A G: Q:FF SET:A RES:D CLK:G 
        // Equate F = A
        let clbAG = tiles[6][0].clb;
        clbAG.decode(bitstream);
        assert.equal(clbAG.configString, 'X:G Y:G F:A G: Q:FF SET:A RES:D CLK:G')
        assert.equal(clbAG.configBase, 'FG');
        assert.equal(clbAG.configNf, 0xd2);
        assert.equal(clbAG.configNg, 0x96);

        // AH: F/F/LATCH/F/G/C, G=Q
        // Editblk AH
        // Base FG
        // Config X:F Y:F F: G:Q Q:LATCH SET:F RES:G CLK:C 
        // Equate G = Q
        // 
        let clbAH = tiles[7][0].clb;
        clbAH.decode(bitstream);
        assert.equal(clbAH.configString, 'X:F Y:F F: G:Q Q:LATCH SET:F RES:G CLK:C')
        assert.equal(clbAH.configBase, 'FG');
        assert.equal(clbAH.configNf, 0xd2);
        assert.equal(clbAH.configNg, 0x96);

        // FA: F/G/FF/F/D/K-NOT, F=B, G=B
        // Editblk FA
        // Base FG
        // Config X:F Y:G F:B G:B Q:FF SET:F RES:D CLK:K:NOT 
        // Equate F = B
        // Equate G = B
        let clbFA = tiles[0][5].clb;
        clbFA.decode(bitstream);
        assert.equal(clbFA.configString, 'X:F Y:G F:B G:B Q:FF SET:F RES:D CLK:K:NOT')
        assert.equal(clbFA.configBase, 'FG');
        assert.equal(clbFA.configNf, 0xd2);
        assert.equal(clbFA.configNg, 0x96);

        // FE: blanks/NOT, "base FGM", F=A, G=C
        // Editblk FE
        // Base FGM
        // Config X: Y: F:A G:C Q: SET: RES: CLK:NOT 
        // Equate F = A
        // Equate G = C
        let clbFE = tiles[4][5].clb;
        clbFE.decode(bitstream);
        assert.equal(clbFE.configString, 'X: Y: F:A G:C Q: SET: RES: CLK:NOT')
        assert.equal(clbFE.configBase, 'FGM');
        assert.equal(clbFE.configNf, 0xd2);
        assert.equal(clbFE.configNg, 0x96);

        // FH: F/Q/FF/F/D/F-NOT, "base F", F=A@B@C@Q
        // Editblk FH
        // Base F
        // Config X:F Y:Q F:A:B:C:Q Q:FF SET:F RES:D CLK:F:NOT 
        // Equate F = A@B@C@Q
        // 
        let clbFH = tiles[7][5].clb;
        clbFH.decode(bitstream);
        assert.equal(clbFH.configString, 'X:F Y:Q F:A:B:C:Q Q:FF SET:F RES:D CLK:F:NOT')
        assert.equal(clbFH.configBase, 'F');
        assert.equal(clbFH.configNf, 0xd2);
        assert.equal(clbFH.configNg, 0x96);

        // HA: M/M/FF/M/M/M, F=A+B+~C, G=~A+B+C
        // Editblk HA
        // Base FGM
        // Config X:M Y:M F:A:B:C G:A:B:C Q:FF SET:M RES:M CLK:M 
        // Equate F = A+B+~C
        // Equate G = ~A+B+C
        let clbHA = tiles[0][7].clb;
        clbHA.decode(bitstream);
        assert.equal(clbHA.configString, 'X:M Y:M F:A:B:C G:A:B:C Q:FF SET:M RES:M CLK:M')
        assert.equal(clbHA.configBase, 'FGM');
        assert.equal(clbHA.configNf, 0xd2);
        assert.equal(clbHA.configNg, 0x96);

        // HD: F/F/FF/F/F/F-not, F=A+~B+C*~D
        // Editblk HD
        // Base F
        // Config X:F Y:F F:A:B:C:D Q:FF SET:F RES:F CLK:F:NOT 
        // Equate F = A+~B+C*~D
        // 
        let clbHD = tiles[3][7].clb;
        clbHD.decode(bitstream);
        assert.equal(clbHD.configString, 'X:F Y:F F:A:B:C:D Q:FF SET:F RES:F CLK:F:NOT')
        assert.equal(clbHD.configBase, 'F');
        assert.equal(clbHD.configNf, 0xd2);
        assert.equal(clbHD.configNg, 0x96);

        // HH: Q/Q/LATCH/M/D/NOT M, "base FGM", F = A+B+C, G=B+C+Q
        // Editblk HH
        // Base FGM
        // Config X: Y: F:A:B:C G:B:C:Q Q: SET: RES: CLK: 
        // Config X:Q Y:Q F:A:B:C G:B:C:Q Q:LATCH SET:M RES:D CLK:M:NOT 
        // Equate F = A+B+C
        // Equate G = B+C+Q
        let clbHH = tiles[7][7].clb;
        clbHH.decode(bitstream);
        assert.equal(clbHH.configString, 'X:Q Y:Q F:A:B:C G:B:C:Q Q:LATCH SET:M RES:D CLK:M:NOT')
        assert.equal(clbHH.configBase, 'FGM');
        // Config X: Y: F:A:B:C G:B:C:Q Q: SET: RES: CLK: 
        assert.equal(clbHH.configNf, 0xd2);
        assert.equal(clbHH.configNg, 0x96);

        done();
      });
    });

  });
</script>


</html>
