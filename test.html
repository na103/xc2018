<!DOCTYPE html>
<!-- Note: test must be run through a proxy, not from the file. -->
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>Test Suite</title>
    <link rel="stylesheet" href="https://code.jquery.com/qunit/qunit-2.11.2.css">
  </head>
  <body>
    <div id="qunit"></div>
    <div id="qunit-fixture"></div>
    <script src="https://code.jquery.com/qunit/qunit-2.11.2.js"></script>
    <script src="draw.js"></script>
    <script src="parse.js"></script>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.min.js"></script>
    <div id="result"></div>
</body>

<script>
  function mkBitstream() {
    let bitstream = new Array(160);
    for (var x = 0; x < 160; x++) {
      bitstream[x] = new Array(71);
    }
    return bitstream;
  }

  function formula4(nf, f1, f2, f3, f4) {
    return nf + f1 + ' ' + f2 + ' ' + f3 + ' ' + f4;
  }

  function formula3(nf, f1, f2, f3) {
    return nf + f1 + ' ' + f2 + ' ' + f3;
  }

  QUnit.module('draw', { beforeEach: function() {
      initNames();
  }}, function() {

    QUnit.test('test initNames', function(assert) {
      assert.deepEqual(colInfo['col.A.local.1'], [5, 26], 'col.A.local.1');
    });

    QUnit.skip('validate tile coords', function(assert) {
      initTiles();

      assert.deepEqual(tiles[0][0].screenPt, [78, 68]);
      assert.deepEqual(tiles[0][3].screenPt, [78, 284]);
      assert.deepEqual(tiles[0][8].screenPt, [78, 644]);
      assert.deepEqual(tiles[5][0].screenPt, [438, 68]);
      assert.deepEqual(tiles[5][7].screenPt, [438, 572]);
      assert.deepEqual(tiles[5][8].screenPt, [438, 644]);
      assert.deepEqual(tiles[8][0].screenPt, [654, 68]);
      assert.deepEqual(tiles[8][4].screenPt, [654, 356]);
      assert.deepEqual(tiles[8][8].screenPt, [654, 644]);

      assert.deepEqual(tiles[0][0].gPt, [0, 0]);
      assert.deepEqual(tiles[0][3].gPt, [0, 60]);
      assert.deepEqual(tiles[0][8].gPt, [0, 160]);
      assert.deepEqual(tiles[5][0].gPt, [95, 0]);
      assert.deepEqual(tiles[5][7].gPt, [95, 140]);
      assert.deepEqual(tiles[5][8].gPt, [95, 160]);
      assert.deepEqual(tiles[8][0].gPt, [152, 0]);
      assert.deepEqual(tiles[8][4].gPt, [152, 80]);
      assert.deepEqual(tiles[8][8].gPt, [152, 160]);

      assert.deepEqual(tiles[0][0].bitPt, [3, 1]);
      assert.deepEqual(tiles[0][3].bitPt, [3, 26]);
      assert.deepEqual(tiles[0][8].bitPt, [3, 67]);
      assert.deepEqual(tiles[5][0].bitPt, [95, 1]);
      assert.deepEqual(tiles[5][7].bitPt, [95, 59]);
      assert.deepEqual(tiles[5][8].bitPt, [95, 67]);
      assert.deepEqual(tiles[8][0].bitPt, [151, 1]);
      assert.deepEqual(tiles[8][4].bitPt, [151, 34]);
      assert.deepEqual(tiles[8][8].bitPt, [151, 67]);
    });

    // Reads all the SWn.RBT files and makes sure the appropriate Switch pins are connected.
    QUnit.skip('switch files', function(assert) {
      let done = assert.async(120)
      for (var i = 0; i < 120; i++) {
        // These are all asynchronous because of the file fetching.
        // done() must be called filenames.length times for the test to complete.
        testSwitchFile('SWITCH' + i, assert, done);
      }
    });

    // Test the named file.
    function testSwitchFile(name, assert, done) {
      $.get( 'testfiles/' + name + '.RBT', function(rbt, status) {
        assert.equal(status, "success");
        $.get( 'testfiles/' + name + '.LCA', function(lca, status) {
          assert.equal(status, "success");
          // loaded rbt and lca
          let m = lca.match(/^;([^:]+):/)
          assert.ok(m);
          let sw = m[1]; // e.g "AC.8.1.5 AC.8.1.6"
          let pin1 = parseInt(sw[7]);
          let pin2 = parseInt(sw[16]);
          let x = sw.charCodeAt(1) - "A".charCodeAt(0);
          let y = sw.charCodeAt(0) - "A".charCodeAt(0);

          let tile = new Tile(x, y);
          let bitstream = rbtParse(rbt);
          tile.decode(bitstream);
          if (sw[5] == 1) {
            // Switch 1 has a wire
            assert.deepEqual(tile.switch1.wires, [[pin1, pin2]]);
            assert.deepEqual(tile.switch2.wires, []);
          } else if (sw[5] == 2) {
            // Switch 2 has a wire
            assert.deepEqual(tile.switch1.wires, []);
            assert.deepEqual(tile.switch2.wires, [[pin1, pin2]]);
          } else {
            assert.ok(false);
          }
          done();
        });
      });
    }

    // The flip flop encoding of XACT doesn't entirely make sense.
    // CLK:G and CLK:K:NOT have the exact same encoding, even though they are different.
    // This seems like a bug in XACT since these have two different physical meanings.
    // (I'm not sure from the hardware what actually happens in this case.)
    //
    // The cases Q: and CLK: (no output or no clock) yield an inoperative flip flop.
    // However, they have encodings. CLK: is encoded by a separate bit, which makes sense.
    // But Q: is the same as Q:LATCH with the clock inverted, which is a bit strange.
    // In addition Q: (no definition) has the same encoding as Q:LATCH with the clock inverted.
    //
    // The point is that the bitstream is ambiguous at best.

    QUnit.skip('test clb', function(assert) {
      let done = assert.async();
      $.get( 'testfiles/CLBTEST.RBT', function(rbt, status) {
        assert.equal(status, "success");
        initTiles();
        let bitstream = rbtParse(rbt);

        // Test the most reasonable Q/clk cases
        let clb = tiles[1][2].clb;
        assert.equal(clb.name, 'CB')
        clb.decode(bitstream);
        // TODO: strip out unused X, Y, F, G, 
        assert.equal(clb.configString, 'X:Q Y:Q F:B:C:Q G:B:C:Q Q:FF SET: RES: CLK:K');

        clb = tiles[2][2].clb;
        assert.equal(clb.name, 'CC')
        clb.decode(bitstream);
        assert.equal(clb.configString, 'X:Q Y:Q F:B:C:Q G:B:C:Q Q:FF SET: RES: CLK:C');

        clb = tiles[3][2].clb;
        assert.equal(clb.name, 'CD')
        clb.decode(bitstream);
        assert.equal(clb.configString, 'X:Q Y:Q F:B:C:Q G:B:C:Q Q:FF SET: RES: CLK:G');

        clb = tiles[4][2].clb;
        assert.equal(clb.name, 'CE')
        clb.decode(bitstream);
        assert.equal(clb.configString, 'X:Q Y:Q F:B:C:Q G:B:C:Q Q:LATCH SET: RES: CLK:K');

        clb = tiles[5][2].clb;
        assert.equal(clb.name, 'CF')
        clb.decode(bitstream);
        assert.equal(clb.configString, 'X:Q Y:Q F:B:C:Q G:B:C:Q Q:LATCH SET: RES: CLK:C');

        clb = tiles[6][2].clb;
        assert.equal(clb.name, 'CG')
        clb.decode(bitstream);
        assert.equal(clb.configString, 'X:Q Y:Q F:B:C:Q G:B:C:Q Q:LATCH SET: RES: CLK:G');

        // Now some miscellaneous tests

        clb = tiles[1][1].clb;
        assert.equal(clb.name, 'BB')
        clb.decode(bitstream);
        assert.equal(clb.configString, 'X:F Y:G F:B:C:D G:A:B:Q Q:LATCH SET:A RES:D CLK:K')
        assert.equal(clb.configBase, 'FG');
        assert.equal(clb.configNf, 254);
        assert.equal(clb.configNg, 254);

        // Base FG
        // Equate G = B+C
        clb = tiles[3][1].clb;
        assert.equal(clb.name, 'BD')
        clb.decode(bitstream);
        assert.equal(clb.configString, 'X:Q Y:Q F:A:B:C G:B:C:Q Q:FF SET:F RES:G CLK:NOT');
        assert.equal(clb.configBase, 'FG');
        assert.equal(clb.configNf, 254);
        assert.equal(clb.configNg, 254);

        // BE G F / / / C-NOT
        clb = tiles[4][1].clb;
        assert.equal(clb.name, 'BE')
        clb.decode(bitstream);
        // TODO: strip out unused variables from F and G
        // assert.equal(clb.configString, 'X:G Y:F F:B:C:Q G:B:C:Q Q: SET: RES: CLK:C:NOT');
        assert.equal(clb.configBase, 'FG');
        assert.equal(clb.configNf, 0);
        assert.equal(clb.configNg, 0);



        // AA: all clear, "base F", F = A+B+C+D
        // Editblk AA
        // Base F
        // Config X: Y: F:A:B:C:D Q: SET: RES: CLK: 
        // Equate F = A+B+C+D
        // 
        clb = tiles[0][0].clb;
        assert.equal(clb.name, 'AA')
        clb.decode(bitstream);
        // assert.equal(clb.configString, 'X: Y: F:B:C:D G:A:B:Q Q: SET: RES: CLK:');
        assert.equal(clb.configBase, 'F');
        assert.equal(clb.configNf, 255);
        assert.equal(clb.configNg, 254);

        // AG: G/G/FF/A/D/G, F=A
        // 
        // Editblk AG
        // Base FG
        // Config X:G Y:G F:A G: Q:FF SET:A RES:D CLK:G 
        // Equate F = A
        clb = tiles[6][0].clb;
        assert.equal(clb.name, 'AG')
        clb.decode(bitstream);
        // assert.equal(clb.configString, 'X:G Y:G F:A G: Q:FF SET:A RES:D CLK:G')
        assert.equal(clb.configBase, 'FG');
        assert.equal(clb.configNf, 170);
        assert.equal(clb.configNg, 0);

        // AH: F/F/LATCH/F/G/C, G=Q
        // Editblk AH
        // Base FG
        // Config X:F Y:F F: G:Q Q:LATCH SET:F RES:G CLK:C 
        // Equate G = Q
        // 
        clb = tiles[7][0].clb;
        assert.equal(clb.name, 'AH')
        clb.decode(bitstream);
        // assert.equal(clb.configString, 'X:F Y:F F: G:Q Q:LATCH SET:F RES:G CLK:C')
        assert.equal(clb.configBase, 'FG');
        assert.equal(clb.configNf, 0);
        assert.equal(clb.configNg, 240);

        // FA: F/G/FF/F/D/K-NOT, F=B, G=B
        // Editblk FA
        // Base FG
        // Config X:F Y:G F:B G:B Q:FF SET:F RES:D CLK:K:NOT 
        // Equate F = B
        // Equate G = B
        clb = tiles[0][5].clb;
        assert.equal(clb.name, 'FA')
        clb.decode(bitstream);
        // assert.equal(clb.configString, 'X:F Y:G F:B G:B Q:FF SET:F RES:D CLK:K:NOT')
        assert.equal(clb.configBase, 'FG');
        assert.equal(clb.configNf, 170);
        assert.equal(clb.configNg, 170);

        // FE: blanks/NOT, "base FGM", F=A, G=C
        // Editblk FE
        // Base FGM
        // Config X: Y: F:A G:C Q: SET: RES: CLK:NOT 
        // Equate F = A
        // Equate G = C
        clb = tiles[4][5].clb;
        assert.equal(clb.name, 'FE')
        clb.decode(bitstream);
        // assert.equal(clb.configString, 'X: Y: F:A G:C Q: SET: RES: CLK:NOT')
        assert.equal(clb.configBase, 'FGM');
        assert.equal(clb.configNf, 170);
        assert.equal(clb.configNg, 252);

        // FH: F/Q/FF/F/D/F-NOT, "base F", F=A@B@C@Q
        // Editblk FH
        // Base F
        // Config X:F Y:Q F:A:B:C:Q Q:FF SET:F RES:D CLK:F:NOT 
        // Equate F = A@B@C@Q
        // 
        clb = tiles[7][5].clb;
        assert.equal(clb.name, 'FH')
        clb.decode(bitstream);
        // assert.equal(clb.configString, 'X:F Y:Q F:A:B:C:Q Q:FF SET:F RES:D CLK:F:NOT')
        assert.equal(clb.configBase, 'F');
        assert.equal(clb.configNf, 105);
        assert.equal(clb.configNg, 0x96);

        // HA: M/M/FF/M/M/M, F=A+B+~C, G=~A+B+C
        // Editblk HA
        // Base FGM
        // Config X:M Y:M F:A:B:C G:A:B:D Q:FF SET:M RES:M CLK:M 
        // Equate F = A+B+~C
        // Equate G = ~A+B+D
        clb = tiles[0][7].clb;
        assert.equal(clb.name, 'HA')
        clb.decode(bitstream);
        assert.equal(clb.configString, 'X:M Y:M F:A:B:C G:A:B:D Q:FF SET:M RES:M CLK:M')
        assert.equal(clb.configBase, 'FGM');
        assert.equal(clb.configNf, 239);
        assert.equal(clb.configNg, 253);

        // HD: F/F/FF/F/F/F-not, F=A+~B+C*~D
        // Editblk HD
        // Base F
        // Config X:F Y:F F:A:B:C:D Q:FF SET:F RES:F CLK:F:NOT 
        // Equate F = A+~B+C*~D
        // 
        clb = tiles[3][7].clb;
        assert.equal(clb.name, 'HD')
        clb.decode(bitstream);
        // assert.equal(clb.configString, 'X:F Y:F F:A:B:C:D Q:FF SET:F RES:F CLK:F:NOT')
        assert.equal(clb.configBase, 'F');
        assert.equal(clb.configNf, 174);
        assert.equal(clb.configNg, 255);

        // HH: Q/Q/LATCH/M/D/NOT M, "base FGM", F = A+B+C, G=B+C+Q
        // Editblk HH
        // Base FGM
        // Config X: Y: F:A:B:C G:B:C:Q Q: SET: RES: CLK: 
        // Config X:Q Y:Q F:A:B:C G:B:C:Q Q:LATCH SET:M RES:D CLK:M:NOT 
        // Equate F = A+B+C
        // Equate G = B+C+Q
        clb = tiles[7][7].clb;
        assert.equal(clb.name, 'HH')
        clb.decode(bitstream);
        // assert.equal(clb.configString, 'X:Q Y:Q F:A:B:C G:B:C:Q Q:LATCH SET:M RES:D CLK:M:NOT')
        assert.equal(clb.configBase, 'FGM');
        // Config X: Y: F:A:B:C G:B:C:Q Q: SET: RES: CLK: 
        assert.equal(clb.configNf, 254);
        assert.equal(clb.configNg, 254);

        // BC: no settings, default
        clb = tiles[2][1].clb;
        assert.equal(clb.name, 'BC')
        clb.decode(bitstream);
        // assert.equal(clb.configString, 'X:Q Y:Q F:B:C:Q G:B:C:Q Q:LATCH SET: RES: CLK:');
        assert.equal(clb.configBase, 'FG');
        assert.equal(clb.configNf, 0);
        assert.equal(clb.configNg, 0);


        done();
      });
    });

    QUnit.test('test mux', function(assert) {
      // Mux input 2 selects A/B, input 4 low selects C/D, 3 selects E, F.
      // Mux input 1 low selects first in pair, high selects second in pair.
      const inputs = [["A", "B", "2"], ["C", "D", "!4"], ["E", "F", "3"], "1"];
      const mux = new Mux(inputs);
      // Note that the bits and results are active-low, so 1 means not selected.
      let initData = {1: 1, 2: 1, 3: 1, 4: 1};
      Object.entries(initData).forEach(([bitNum , val]) => mux.add(bitNum, val));
      mux.decode();
      assert.deepEqual(mux.pips, {"A": 1, "B": 1, "C": 1, "D": 0, "E": 1, "F": 1});

      initData = {1: 0, 2: 1, 3: 1, 4: 1};
      Object.entries(initData).forEach(([bitNum , val]) => mux.add(bitNum, val));
      mux.decode();
      assert.deepEqual(mux.pips, {"A": 1, "B": 1, "C": 0, "D": 1, "E": 1, "F": 1});

      initData = {1: 1, 2: 1, 3: 0, 4: 0};
      Object.entries(initData).forEach(([bitNum , val]) => mux.add(bitNum, val));
      mux.decode();
      assert.deepEqual(mux.pips, {"A": 1, "B": 1, "C": 1, "D": 1, "E": 1, "F": 0});
    });

    QUnit.skip('test mux substitution', function(assert) {
      const inputs = [["col.X:C.X", "row.X:C.Y", "2"], ["XW.D:WX:D", "XX.X", "!4"], "1"];
      const wanted = [["col.C:C.X", "row.D:C.Y", "2"], ["CC.D:BD:D", "CD.X", "!4"], "1"];
      const result = fillInMuxEntries("CD", inputs);
      assert.deepEqual(result, wanted);
    });

    QUnit.test('test nameToG', function(assert) {
      const iobDecoders = new IobDecoders();
      initNames();
      assert.equal(nameToG("col.F.local.5:row.F.local.4"), "113G66");
      let done = assert.async();
      let errors = 0;
      let undef = 0;
      $.getJSON( 'testfiles/data.js', function(data, status) {
        assert.equal(status, 'success');
        Object.entries(data).forEach(function([name, val]) {
          const result = nameToG(name);
          if (result == undefined) {
            assert.ok(false, "missing: " + name);
            console.log(name, 'unimplemented');
            undef += 1;
          } else if (result != val[2]) {
            assert.equal(result, val[2], name);
            errors += 1;
          } else {
            assert.ok(true, name);
          }
        });
        assert.equal(errors, 0, "errors");
        assert.equal(undef, 0, "unimplemented");
        done();
      });
    });

    QUnit.test('test gToName', function(assert) {
      let ctx = {fillStyle: () => 0, fillRect: () => 0}; // Dummy ctx
      generateIobPips(ctx, pads);
      
      assert.equal(gToName["8G34"], "col.A.local.3:PAD47.O");
      assert.equal(gToName("8G34"), "col.A.local.3:PAD47.O");
      assert.equal(gToName("23G166"), "row.A.local.2:PAD2.I");
      assert.equal(gToName("113G66"), "col.F.local.5:row.F.local.4");
      let done = assert.async();
      let errors = 0;
      let undef = 0;
      $.getJSON( 'testfiles/data.js', function(data, status) {
        assert.equal(status, 'success');
        Object.entries(data).forEach(function([name, val]) {
          const result = gToName(val[2]);
          if (result == undefined) {
            console.log(name, 'unimplemented');
            undef += 1;
          } else if (result != name) {
            console.log(val[2], 'want:', name, 'got:', result);
            errors += 1;
          }
        });
        assert.equal(errors, 0, "errors");
        assert.equal(undef, 0, "unimplemented");
        done();
      });
    });

    QUnit.test('test getSwitchCoords', function(assert) {
      assert.equal(getSwitchCoords("BB.8.1.0")[0], "27G146");
      assert.equal(getSwitchCoords("BB.8.1.1")[0], "28G146");
      assert.equal(getSwitchCoords("BB.8.1.2")[0], "29G145");
      assert.equal(getSwitchCoords("BB.8.1.3")[0], "29G144");
      assert.equal(getSwitchCoords("BB.8.1.4")[0], "28G143");
      assert.equal(getSwitchCoords("BB.8.1.5")[0], "27G143");
      assert.equal(getSwitchCoords("BB.8.1.6")[0], "26G144");
      assert.equal(getSwitchCoords("BB.8.1.7")[0], "26G145");

      assert.equal(getSwitchCoords("IE.8.1.0")[0], "87G8");
      assert.equal(getSwitchCoords("IE.8.1.1")[0], "88G8");
      assert.equal(getSwitchCoords("IE.8.1.2")[0], "89G7");
      assert.equal(getSwitchCoords("IE.8.1.3")[0], "89G6");
      assert.equal(getSwitchCoords("IE.8.1.6")[0], "86G6");
      assert.equal(getSwitchCoords("IE.8.1.7")[0], "86G7");



      assert.equal(getSwitchCoords("FA.8.1.0")[0], "5G70");
      assert.equal(getSwitchCoords("IB.8.2.0")[0], "30G11");
      assert.equal(getSwitchCoords("HA.8.1.1")[0], "6G32");
      assert.equal(getSwitchCoords("CI.8.2.1")[0], "176G124");
      assert.equal(getSwitchCoords("AH.8.1.2")[0], "149G167");
      assert.equal(getSwitchCoords("IF.8.2.2")[0], "112G10");
      assert.equal(getSwitchCoords("IC.8.1.3")[0], "49G6");
      assert.equal(getSwitchCoords("AH.8.2.4")[0], "151G162");
      assert.equal(getSwitchCoords("HI.8.2.5")[0], "175G26");
      assert.equal(getSwitchCoords("HH.8.1.6")[0], "146G30");
      assert.equal(getSwitchCoords("AC.8.2.7")[0], "49G164");
    });

    QUnit.test('test pad name generation', function(assert) {
      const iobDecoders = new IobDecoders();
      let done = assert.async();
      let errors = 0;
      let undef = 0;
      let success = 0;
      $.getJSON( 'testfiles/data.js', function(data, status) {
        assert.equal(status, 'success');
        Object.entries(data).forEach(function([name, val]) {
          if (!name.includes('PAD')) {
            return;
          }
          if (IobDecoders.nameToG[name] == undefined) {
            if (IobDecoders.gToName[val[2]] != undefined) {
              assert.equal(IobDecoders.gToName[val[2]], name, 'bad name ' + name);
              if (IobDecoders.gToName[val[2]] != name) {
                errors += 1;
                return;
              }
            }
            assert.ok(false, "missing " + name);
            undef += 1;
            return;
          }
          const g = IobDecoders.nameToG[name];
          assert.equal(IobDecoders.gToName[g], name, "G test " + name);
          if (g != val[2]) {
            errors += 1;
          } else {
            success += 1;
          }
          assert.equal(g, val[2], name);
        });
        assert.equal(errors, 0, "errors with " + success + " successes.");
        assert.equal(undef, 0, "unimplemented");
        done();
      });
    });


  });
</script>


</html>
